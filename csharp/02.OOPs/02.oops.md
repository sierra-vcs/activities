Classes & Objects, Constructors, Inheritance, Polymorphism, Interfaces.
---
### Assignments
* [CS.1.011 -Class & Object Fundamentals — Meter](#CS1011)
* [CS.1.012 -Constructors & Overloads — Tariff](#CS1012)
* [CS.2.013 -Inheritance Basics — Device → Meter / Gateway](#CS2013)
* [CS.2.014 -Interface for Reading — IReadable](#CS2014)
* [CS.2.015 -Polymorphism with Strategy — IBillingRule](#CS2015)
* [CS.2.016 -Constructors, Encapsulation & Computed Props — LoadProfileDay](#CS2016)
* [CS.3.017 -Abstract Base + Overrides — AlarmRule](#CS3017)
* [CS.3.018 -Interface Segregation + Multiple Implementations — IDataIngestor](#CS3018)
* [CS.3.019 -Polymorphic Billing with Add-on Interfaces — IRebate](#CS3019)
* [CS.3.020 -Domain Model with Inheritance & Polymorphic Processing — Event Hierarchy](#CS3020)
---
<br>

What learners should hand in
----------------------------

-   A single solution with **10 small classes/files** or **`Program.cs`** with `#region` per assignment.

-   For each assignment: a short comment block containing:

    -   **Concepts used** (e.g., abstract class, interface, override).

    -   **Why** certain choices were made (e.g., strategy vs switch).

    -   **Complexities** (e.g., O(n) scans, defensive copying).

* * * * *

Suggested evaluation rubric (quick)
-----------------------------------

-   **Correctness (40%)**: outputs match expectations, edge cases handled.

-   **OO Design (35%)**: sound class design, encapsulation, substitution principle respected.

-   **Code Quality (15%)**: naming, comments, small cohesive methods.

-   **Stretch Goals (10%)**: attempted + working.


<br>

---
# CS.1.011
## Class & Object Fundamentals --- `Meter`
-----------------------------------------

**Goal:** Encapsulate state + behavior.

**Problem**\
Create a `Meter` class with:

-   Fields/props: `MeterSerial` (string), `Location` (string), `InstalledOn` (DateTime), `LastReadingKwh` (int).

-   Methods:

    -   `AddReading(int deltaKwh)`: adds to `LastReadingKwh` if `deltaKwh > 0`, else ignore.

    -   `Summary()`: returns `"SERIAL Location: X | Reading: Y"`.

**Tasks**

1.  Instantiate two meters, set properties via object initializer.

2.  Call `AddReading` with valid and invalid deltas.

3.  Print `Summary()` for each.

**Expected Output (example)**

```
AP-0001 Location: Feeder-12 | Reading: 15230
AP-0002 Location: DTR-9     | Reading:  9800
```

**Stretch**

-   Make fields **auto-properties** with validation in **set**.

-   Add `ToString()` and just `Console.WriteLine(meter)`.

**Checks**

-   Object creation works; guard against negative deltas; clean formatting.

* * * * *

<br>

# CS.1.012
## Constructors & Overloads --- `Tariff`

**Goal:** Define overloaded constructors + chaining.

**Problem**\
Create a `Tariff` class with:

-   Props: `Name` (string), `RatePerKwh` (double), `FixedCharge` (double).

-   Ctors:

    -   `Tariff(string name)` → defaults: rate=6.0, fixed=50.

    -   `Tariff(string name, double rate)` → defaults fixed=50.

    -   `Tariff(string name, double rate, double fixedCharge)`.

-   `ComputeBill(int units)` → `units * rate + fixed`.

**Tasks**

1.  Create three tariffs using different constructors.

2.  For `units=120`, print computed bill for each.

**Expected Output (example)**

```
DOMESTIC: ₹770.00
COMMERCIAL: ₹1170.00
AGRI: ₹410.00
```

**Stretch**

-   Add `Validate()` that throws if `rate <= 0` or `fixed < 0`. Call in constructors.

**Checks**

-   Proper ctor chaining, defaults applied correctly.

* * * * *

# CS.2.013
## Inheritance Basics --- `Device` → `Meter` / `Gateway`

**Goal:** Establish base class reuse.

**Problem**

-   Base class `Device`:

    -   Props: `Id` (string), `InstalledOn` (DateTime).

    -   Method: `Virtual Describe()` → `"Device Id: ... InstalledOn: ..."`

-   Derived:

    -   `Meter` adds `PhaseCount` (int) and overrides `Describe()` to include it.

    -   `Gateway` adds `IpAddress` (string) and overrides `Describe()`.

**Tasks**

1.  Create `Device[]` with 1 meter + 1 gateway (polymorphic array).

2.  Loop and `Console.WriteLine(d.Describe())`.

**Expected Output**

```
Meter Id: AP-0001 | Installed: 2024-07-01 | Phases: 3
Gateway Id: GW-11 | Installed: 2025-01-10 | IP: 10.0.5.21
```

**Stretch**

-   Mark `Device.Describe()` **virtual** and children **override**; also add `protected` ctor in base.

**Checks**

-   Correct override dispatch via base reference.

* * * * *

# CS.2.014
## Interface for Reading --- `IReadable`

**Goal:** Program to interface.

**Problem**\
Define `IReadable`:

```C#
public interface IReadable
{
    int ReadKwh();             // returns delta since last poll
    string SourceId { get; }
}
```

Implement:

-   `DlmsMeter : IReadable` (returns a random 1--10 kWh).

-   `ModemGateway : IReadable` (returns a random 0--2 kWh representing backfill).

**Tasks**

1.  Put both in `List<IReadable>` and poll 5 times (loop).

2.  Print `"SourceId -> deltaKwh"` for each poll.

**Expected Output (sample)**

```
AP-0001 -> 7
GW-21   -> 1
...
```

**Stretch**

-   Add **seeded** `Random` so results are deterministic for tests.

**Checks**

-   Both classes satisfy interface; loop uses interface only.

* * * * *

# CS.2.015 
## Polymorphism with Strategy --- `IBillingRule`

**Goal:** Replace `switch` with polymorphic strategy.

**Problem**\
Define:

```C#
public interface IBillingRule { double Compute(int units); }
class DomesticRule : IBillingRule { /* 6.0/unit + 50 fixed */ }
class CommercialRule : IBillingRule { /* 8.5/unit + 150 fixed */ }
class AgricultureRule : IBillingRule { /* 3.0/unit + 0 fixed */ }
```

Create `BillingEngine` with `IBillingRule Rule;` and `double GenerateBill(int units)`.

**Tasks**

1.  With `units=120`, compute bills using each rule instance.

2.  Print category + amount.

**Expected Output**

```
DOMESTIC -> ₹770.00
COMMERCIAL -> ₹1170.00
AGRICULTURE -> ₹360.00
```

**Stretch**

-   Add `TimeOfDay` multiplier (e.g., 1.2× for peak) via **optional** ctor arg or property and apply in `Compute`.

**Checks**

-   No `switch` in engine; pure interface polymorphism.

* * * * *

# CS.2.016
## Constructors, Encapsulation & Computed Props --- `LoadProfileDay`


**Goal:** Immutable object + computed members.

**Problem**\
Create:

```c#
class LoadProfileDay
{
    public DateTime Date { get; }
    public int[] HourlyKwh { get; } // length 24
    public LoadProfileDay(DateTime date, int[] hourly)
    {
        // clone array; validate length == 24; values >= 0
    }
    public int Total => /* sum */;
    public int PeakHour => /* 0..23 of max */;
}
```

**Tasks**

1.  Build a valid `HourlyKwh` array; instantiate a day.

2.  Print `Date`, `Total`, `PeakHour`.

**Expected Output**

`2025-10-01 | Total: 82 kWh | PeakHour: 19`

**Stretch**

-   Add `int OutageHours => count of zeros`.

**Checks**

-   Defensive copy, validation in ctor, read-only API.

* * * * *

# CS.3.017
## Abstract Base + Overrides --- `AlarmRule`

**Goal:** Use abstract classes for shared template logic.

**Problem**\
Create:

```c#
abstract class AlarmRule
{
    public string Name { get; }
    protected AlarmRule(string name) => Name = name;
    public abstract bool IsTriggered(LoadProfileDay day);
    public virtual string Message(LoadProfileDay day)
        => $"{Name} triggered on {day.Date:yyyy-MM-dd}";
}

class PeakOveruseRule : AlarmRule
{   // trigger if day.Total > threshold
    private readonly int _threshold;
    public PeakOveruseRule(int threshold) : base("PeakOveruse") => _threshold = threshold;
    public override bool IsTriggered(LoadProfileDay day) => day.Total > _threshold;
}

class SustainedOutageRule : AlarmRule
{   // trigger if consecutive zero hours >= N
    private readonly int _minConsecutive;
    public SustainedOutageRule(int min) : base("SustainedOutage") => _minConsecutive = min;
    public override bool IsTriggered(LoadProfileDay day) { /* scan */ }
}
```

**Tasks**

1.  Build a `LoadProfileDay` with some zeros & highs.

2.  Evaluate rules and print triggered messages.

**Expected Output**

`PeakOveruse triggered on 2025-10-01`

(or both, depending on data)

**Stretch**

-   Add `virtual` `Message` override in `SustainedOutageRule` to include *start hour*.

**Checks**

-   Correct abstract/override usage; O(n) scan for consecutive zeros.

* * * * *

# CS.3.018
## Interface Segregation + Multiple Implementations --- `IDataIngestor`

**Goal:** Hide source specifics behind an interface; compose behaviors.

**Problem**\
Define:

```c#
public interface IDataIngestor
{
    string Name { get; }
    IEnumerable<(DateTime ts, int kwh)> ReadBatch(int count);
}
```

Implement:

-   `DlmsIngestor` → emits `count` hourly tuples (ts, kwh=1..5).

-   `CsvIngestor` → emits from an in-memory string array of CSV lines.

-   `RandomOutageDecorator : IDataIngestor` → wraps any ingestor and randomly sets some `kwh=0`.

**Tasks**

1.  Wrap `new DlmsIngestor()` with `RandomOutageDecorator`.

2.  Call `ReadBatch(10)` and print 10 lines `ts -> kwh`.

**Expected Output**

`[Dlms+Outage] 2025-10-06 10:00 -> 3
...`

**Stretch**

-   Add `IRateLimiter` interface and a decorator that sleeps or skips every Nth record (simulate HES limits).

**Checks**

-   Interface composition, decorator pattern, clean separation of concerns.

* * * * *

# CS.3.019
# Polymorphic Billing with Add-on Interfaces --- `IRebate`

**Goal:** Demonstrate multiple interfaces + dynamic composition.

**Problem**\
Use `IBillingRule` from [CS.2.015](#CS2015) and add:

```c#
public interface IRebate
{
    string Code { get; }
    double Apply(double currentTotal, int outageDays);
}
```

Implement rebates:

-   `NoOutageRebate` → if `outageDays==0` then `-2%`.

-   `HighUsageRebate` → if `units>500` then `-3%`.

Create `BillingContext`:

```c#
class BillingContext
{
    public IBillingRule Rule { get; }
    public List<IRebate> Rebates { get; } = new();
    public BillingContext(IBillingRule rule) => Rule = rule;
    public double Finalize(int units, int outageDays)
    {
        double total = Rule.Compute(units);
        foreach (var r in Rebates) total += r.Apply(total, outageDays);
        return total;
    }
}
```

**Tasks**

1.  Rule = Commercial, units=620, outageDays=0. Apply both rebates.

2.  Print subtotal and final total.

**Expected Output (illustrative)**

```
Subtotal: ₹  8.5*620 + 150 = ₹  5,  420 + 150 = ₹  5,  570.00
Rebates: NO_OUTAGE -2% | HIGH_USAGE -3%
Final: ₹ 5402.10
```

**Stretch**

-   Add `IRebate` that **adds** a penalty when `tamperDays>0`.

**Checks**

-   Multiple interfaces at play; order of application consistent.

* * * * *

# CS.3.020
## Domain Model with Inheritance & Polymorphic Processing --- `Event` Hierarchy


**Goal:** Model real MDMS events + process via polymorphism.

**Problem**\
Create base class:

```c#
abstract class Event
{
    public DateTime When { get; }
    public string MeterSerial { get; }
    protected Event(DateTime when, string meterSerial) { When = when; MeterSerial = meterSerial; }
    public abstract string Category { get; }
    public abstract int Severity { get; } // 1..5
    public virtual string Describe() => $"{When:yyyy-MM-dd HH:mm} [{Category}] {MeterSerial}";
}
```

Derived:

-   `OutageEvent : Event` (Category="OUTAGE", Severity=3, plus `DurationMinutes`).

-   `TamperEvent : Event` (Category="TAMPER", Severity=5, plus `Code`).

-   `VoltageEvent : Event` (Category="VOLTAGE", Severity=2, plus `Voltage`).

**Processor**

```c#
class EventProcessor
{
    public static void PrintTopSevere(IEnumerable<Event> events, int topN)
    {
        // sort by Severity desc, then When desc; print Describe() + extra fields polymorphically
    }
}
```

**Tasks**

1.  Create a mixed list of 8 events across 3 types.

2.  Print top 3 by severity/recency.

**Expected Output**

```
2025-10-06 09:20 [TAMPER] AP-0007 | Code: MISMATCH | Severity: 5
2025-10-05 22:10 [OUTAGE] AP-0003 | Duration: 95 min | Severity: 3
2025-10-05 18:00 [VOLTAGE] AP-0001 | V: 184 | Severity: 2
```

**Stretch**

-   Add `IComparable<Event>` on base to encapsulate sort logic (or custom `Comparer`).

**Checks**

-   Proper use of abstract members; polymorphic data printout.

* * * * *

